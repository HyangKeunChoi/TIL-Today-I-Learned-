# Ch 09. 동시성 제어하기

## 멀티 스레드 환경에 대한 이해

## 동시성 이슈가 어려운 이유
1. 로컬에서는 대부분 하나의 스레드로 테스트
2. 이슈가 발생하더라도 오류가 발생하지 않는다.
3. 코드에서 잘 보이지 않는다.
4. 항상 발생하지 않고 비결정적으로 발생한다.

# 동시성을 대처하는 가장 보편적인 방법
+ 락

## 락의 범위를 최소화 하는것이 중요
+ 락의 범위를 최소화하는 것이 중요
+ MySQL에서는 트랜잭션의 커밋 혹은 롤백시점에 잠금이 풀린다.

## MySQL에서는 쓰기락, 읽기락 두 가지 잠금을 제공
+ 읽기락이 걸려있어도 다른 읽기락이 데이터를 읽을 수 있다.
+ 쓰기락이 걸려있으면 어떤 트랜잭션이와도 대기상태가 된다.
![image](https://github.com/HyangKeunChoi/TIL-Today-I-Learned-/assets/49984996/7b75a52e-d781-49bd-81f1-c2dcd5a24c95)

+ 읽기락은 SELECT FOR SHARE
+ 쓰기락은 SELECT FOR UPDATE 혹은 UPDATE, DELETE 쿼리를 통해 획득

+ 매번 잠금이 발생할 경우,성능저하를 피할 수 없음
+ MySQL에서는 일반 SELECT는 non-blocking consistent read(대기 없는 read)로 동작

## 락의 종류
+ 테이블 락 : 테이블 전체를 잠금
+ 레코드 락 : 로우하나를 잠금(가장 중요)
+ 갭 락 : 로우와 로우 사이를 잠금

+ **MySQL에서는 잠금은 row가 아니라 인덱스를 잠근다.**
  - 인덱스가 없는 조건으로 Locking Read시 불필요한 데이터들이 잠길 수 있다.
    - 인덱스에 따라서 락이 잡히는 범위가 달라지기 때문에

 + 실습으로 락이 걸려있는지 확인하는 예제
 
```sql
select * from performance_schema.data_locks;
```
+ LOCK_MODE : X(쓰기) 잠금이 걸려있다.

### 공부해봐야 하는 키워드
+ Java에서의 동시성 이슈 해결방법
+ 분산환경에서의 동시성 이슈 제어방법
+ MySQL의 넥스트 키락이 등작한 배경 : 넥스트 키 락 - 갭락과 레코드락이 합쳐진 개념
+ MySQL 외래키로 인한 잠금이 발생하는 경우
+ MySQL 데드락 케이스

## 좋아요 기능 구현
+ swagger에 curl 명령어 복붙 가능
+ 좋아요 쪽에서 동시성 문제가 발생하기 너무 좋다.
+ curl 명령어에 | jq하니까 데이터가 json으로 보기 쉽게 펼쳐짐
+ break point걸고 마우스 우클릭 - suspend All말고 thread로 선택! (2개의 요청을 동시에 보내도 기다린다)
  - All로하면 요청을 1개밖에 테스트하지 못함 
  - curl명령으로 요청을 두개 보냄
  - thread 각각이 break point가 걸림

## 낙관적 락 (feat 비관적 락),  낙관적 락으로 좋아요 구현
+ 동시성 제어를 위한 가장 보편적인 방법은 락을 통한 줄세우기
  - 비관적 락(동시성 이슈가 발생할 꺼라고 비관적으로 생각)
    - 락을 통한 동시성 제어는 불필요한 대기 상태를 만듬
+ 동시성이 빈번하지 않은 쿼리로 인해 다른 쿼리가 대기한다면? - 성능 저하
+ 낙관적 락 개념 : 동시성 이슈가 빈번하지 않길 기대하고, 어플리케이션에서 제어한다.
   - CAS(compare and set)을 통해 제어
      - 버전 관리을 추가로 처리한다 (버전 미스매치로 쿼리가 실패할 수도 있다.)
      - **실패할 경우 개발자가 직접 재처리 해야한다.**
   - 분산환경에서는 비관적락을 간단하게 쓸수 없다. 다른 DB를 쓰거나, 분산락 써야함
 
## 컬럼기반의 좋아요 기능을 테이블로 분리

### 수십만명이 좋아요를 누르는 과정
+ 비관적락 : 좋아요 레코드에 업데이트를 치기 위해서 수십만명이 줄을 선다.
+ 낙관적락 : 끈임 없이 실패를 한다.
+ 테이블로 분리해서 성능 병목 지점을 해소 해보자.
  - 락을 안잡아도 됨 왜냐하면 insert이기 때문에
  - UPDATE 치려고 하기 때문에 경합을 하지도 않는다.
  - DTO만들때마다 count쿼리가 발생한다.
 

