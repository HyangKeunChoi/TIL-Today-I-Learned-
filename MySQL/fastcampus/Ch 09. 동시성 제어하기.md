# Ch 09. 동시성 제어하기

## 멀티 스레드 환경에 대한 이해

## 동시성 이슈가 어려운 이유
1. 로컬에서는 대부분 하나의 스레드로 테스트
2. 이슈가 발생하더라도 오류가 발생하지 않는다.
3. 코드에서 잘 보이지 않는다.
4. 항상 발생하지 않고 비결정적으로 발생한다.

# 동시성을 대처하는 가장 보편적인 방법
+ 락

## 락의 범위를 최소화 하는것이 중요
+ 락의 범위를 최소화하는 것이 중요
+ MySQL에서는 트랜잭션의 커밋 혹은 롤백시점에 잠금이 풀린다.

## MySQL에서는 쓰기락, 읽기락 두 가지 잠금을 제공
+ 읽기락이 걸려있어도 다른 읽기락이 데이터를 읽을 수 있다.
+ 쓰기락이 걸려있으면 어떤 트랜잭션이와도 대기상태가 된다.
![image](https://github.com/HyangKeunChoi/TIL-Today-I-Learned-/assets/49984996/7b75a52e-d781-49bd-81f1-c2dcd5a24c95)

+ 읽기락은 SELECT FOR SHARE
+ 쓰기락은 SELECT FOR UPDATE 혹은 UPDATE, DELETE 쿼리를 통해 획득

+ 매번 잠금이 발생할 경우,성능저하를 피할 수 없음
+ MySQL에서는 일반 SELECT는 non-blocking consistent read(대기 없는 read)로 동작

## 락의 종류
+ 테이블 락 : 테이블 전체를 잠금
+ 레코드 락 : 로우하나를 잠금(가장 중요)
+ 갭 락 : 로우와 로우 사이를 잠금

+ **MySQL에서는 잠금은 row가 아니라 인덱스를 잠근다.**
  - 인덱스가 없는 조건으로 Locking Read시 불필요한 데이터들이 잠길 수 있다.
    - 인덱스에 따라서 락이 잡히는 범위가 달라지기 때문에

 + 실습으로 락이 걸려있는지 확인하는 예제
 
```sql
select * from performance_schema.data_locks;
```
+ LOCK_MODE : X(쓰기) 잠금이 걸려있다.

### 공부해봐야 하는 키워드
+ Java에서의 동시성 이슈 해결방법
+ 분산환경에서의 동시성 이슈 제어방법
+ MySQL의 넥스트 키락이 등작한 배경 : 넥스트 키 락 - 갭락과 레코드락이 합쳐진 개념
+ MySQL 외래키로 인한 잠금이 발생하는 경우
+ MySQL 데드락 케이스

## 좋아요 기능 구현
+ swagger에 curl 명령어 복붙 가능
+ 좋아요 쪽에서 동시성 문제가 발생하기 너무 좋다.
+ curl 명령어에 | jq하니까 데이터가 json으로 보기 쉽게 펼쳐짐
+ break point걸고 마우스 우클릭 - suspend All말고 thread로 선택! (2개의 요청을 동시에 보내도 기다린다)
  - All로하면 요청을 1개밖에 테스트하지 못함 
  - curl명령으로 요청을 두개 보냄
  - thread 각각이 break point가 걸림
