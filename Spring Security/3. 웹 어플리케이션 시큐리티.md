# 웹 어플리케이션 시큐리티

## 스프링 시큐리티 ignoring() 1부
+ 모든 웹페이지 호출시 시프링 시큐리티가 처리 하였다.
  - 파비콘 같은 요청도 불필요하게 스프링시큐리티가 처리하고 있다.
  - static 리소스는 스프링 시큐리티가 처리하지 않도록 하는 과정이 필요하다. 

+ WebSecurity의 ignoring()을 사용해서 시큐리티 필터 적용을 제외할 요청을 설정할 수 있다.
```java
@Override
public void configure(WebSecurity web) throws Exception {
    web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());
}
```

> 필터 체인 갯수가 0개 (필터 체인에 걸리지 않음)

## ignoring() 2부

+ 위 방법 대신 아래 방법으로 해도 된다.
  - 추천하진 않는다.
  - 아래 방법은 필터 체인에 걸리기 때문에 성능상 좋지 않다.
```java
http.authorizeRequests()
.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
```

+ 이런 설정으로도 같은 결과를 볼 수는 있지만 스프링 시큐리티 필터가 적용된다는 차이가 있다.
  - 동적 리소스는 http.authorizeRequests()에서 처리하는 것을 권장합니다.
  - 정적 리소스는 WebSecurity.ignore()를 권장하며 예외적인 정적 자원 (인증이 필요한 정적자원이 있는 경우)는 http.authorizeRequests()를 사용할 수 있습니다.

## Async 웹 MVC를 지원하는 필터: WebAsyncManagerIntegrationFilter
+ SecurityContext가 스레드 로컬을 사용하는데, spring mvc의 Async한 핸들러는 다른 스레드를 사용하게 된다.
  - 다른 스레드지만 동일한 시큐리티 컨텍스트를 지원해주는 필터가 WebAsyncManagerIntegrationFilter

+ 스프링 MVC의 Async 기능(핸들러에서 Callable을 리턴할 수 있는 기능)을 사용할 때에도 SecurityContext를 공유하도록 도와주는 필터.
  - PreProcess: SecurityContext를 설정한다.
  - Callable: 비록 다른 쓰레드지만 그 안에서는 동일한 SecurityContext를 참조할 수 있다.
  - PostProcess: SecurityContext를 정리(clean up)한다.

+ @Async를 사용한 서비스를 호출하는 경우는 어떻게 처리할까?

## 스프링 시큐리티와 @Async
+ @Async를 사용한 서비스를 호출하는 경우
  - @Async : 별도의 스레드를 만들어서 비동기적으로 호출하게 해주는 어노테이션
  - 쓰레드가 다르기 때문에 SecurityContext를 공유받지 못한다.

+ 해결
```java
SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);
```
+ SecurityContext를 자식 쓰레드에도 공유하는 전략.
+ @Async를 처리하는 쓰레드에서도 SecurityContext를 공유받을 수 있다.

+ https://docs.oracle.com/javase/7/docs/api/java/lang/InheritableThreadLocal.html

## SecurityContext 영속화 필터: SecurityContextPersistenceFilter

#### 사용 방법
+ SecurityContextRepository를 사용해서(위임해서) 기존의 SecurityContext를 읽어오거나 초기화 한다.

+ 기본으로 사용하는 전략은 HTTP Session을 통해 사용한다.
+ Spring-Session(https://spring.io/projects/spring-session#learn)과 연동하여 세션 클러스터를 구현할 수 있다. (이 강좌에서는 다루지 않습니다.)

![image](https://user-images.githubusercontent.com/49984996/148961921-6619bfaa-86b6-41f6-b449-d27083808120.png)

## 시큐리티 관련 헤더 추가하는 필터: HeaderWriterFilter
+ 직접 사용할 일은 없지만 어떤 일을 하는지 알아보자.

+ 응답 헤더에 시큐리티 관련 헤더를 추가해주는 필터
  - XContentTypeOptionsHeaderWriter: 마임 타입 스니핑 방어.
    - 마인 타입 스니핑이란? 브라우저 단에서 마인 타입을 강제로 실행하는 경우가 있는데, Header정보와 맞지 않는 마인 타입은 실행하지 못하게 해주는 필터이다.
  - XXssProtectionHeaderWriter: 브라우저에 내장된 XSS 필터 적용.
  - CacheControlHeadersWriter: 캐시 히스토리 취약점 방어.
  - HstsHeaderWriter: HTTPS로만 소통하도록 강제.
  - XFrameOptionsHeaderWriter: clickjacking 방어.

## CSRF 어택 방지 필터: CsrfFilter
+ CORS와는 다른것이다.
+ 의도한 사용자만 리소스를 변경할 수 있도록 허용하는 필터
  - CSRF 토큰을 사용하여 방지.

+ CSRF : 원치 않는 요청을 임의대로 만들어서 보냄
  - 보통은 브라우저 단에서 특정 요청이 같은 도메인인지 확인해서 맞으면 요청을 보내도록 되어 있다.
    - 타 사이트의 도메인으로 요청 보내지 못하게 하기 위해서

+ CSRF 어택 방지 필터
  - 인증된 유저의 계정을 사용해 악의적인 변경 요청을 만들어 보내는 기법.
  - https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
  - https://namu.wiki/w/CSRF
  - CORS를 사용할 때 특히 주의 해야 함.
    - 타 도메인에서 보내오는 요청을 허용하기 때문에...
    - 예를들어 공공API같은 경우는 다른도메인에서도 호출가능하도록 허용해야 한다.
    - 안전한 방법 : 인증서를 통해 인증이 완료되면 양방향 통신
    - 가장 간단한 방법 : CORS - 도메인이 일치하지 않더라도, 도메인을 열어서 리소스를 제공한다. (CSRF공격에 노출될 여지가 있다.)
    - https://en.wikipedia.org/wiki/Cross-origin_resource_sharing
    - 스프링 시큐리티에서는 특정한 토큰을 사용해서, 리소스 변경하는 요청같은 경우는 서버쪽에 토큰이 있으면 처리한다.

## CSRF 토큰 사용 예제

+ 스프링이 자동설정으로 거의 다 해주기 때문에 우리가 크게 할 작업은 없다.
+ JSP에서 스프링 MVC가 제공하는 <form:form> 태그 또는 타임리프 2.1+ 버전을 사용할 때 폼에 CRSF 히든 필드가 기본으로 생성 됨.
  - 직접 코딩 안해도 된다. 
  - post요청의 경우 csrf필터에서 폼의 히든필드로 있었던 토큰값이 일치하는지 확인한다. 
