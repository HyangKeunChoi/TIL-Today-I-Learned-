## 1. 폼 인증 예제 살펴보기

+ Principal : 인증된 사용자가 있다면, 인증된 사용자에 대한 정보를 Principal이라는 인터페이스 타입으로, 메소드에서 argument resolver로 사용

+ 홈 페이지
  - /
  - 인증된 사용자도 접근할 수 있으며 인증하지 않은 사용자도 접근할 수 있습니다.
  - 인증된 사용자가 로그인 한 경우에는 이름을 출력할 것.

+ 정보
  - /info
  - 이 페이지는 인증을 하지 않고도 접근할 수 있으며, 인증을 한 사용자도 접근할 수 있습니다.

+ 대시보드
  - /dashboard
  - 이 페이지는 반드시 로그인 한 사용자만 접근할 수 있습니다.
  - 인증하지 않은 사용자가 접근할 시 로그인 페이지로 이동합니다.

+ 어드민
  - /admin
  - 이 페이지는 반드시 **ADMIN 권한을 가진 사용자만 접근**할 수 있습니다.
  - 인증하지 않은 사용자가 접근할 시 로그인 페이지로 이동합니다.
  - 인증은 거쳤으나, 권한이 충분하지 않은 경우 에러 메시지를 출력합니다.

## 스프링 시큐리티 연동

+ 스프링 시큐리티 의존성 추가하기
  - 스프링 부트 도움 받아 추가하기
    - 스타터(Starter) 사용
    - 버전 생략 - 스프링 부트의 의존성 관리 기능 사용

```java
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

+ 스프링 시큐리티 의존성을 추가하고 나면
  - 모든 요청은 인증을 필요로 합니다. (-> 인증 없어도 볼 수 있는 페이지가 필요하다.) 
  - 기본 유저가 생성됩니다.(로그인 정보, 지금은 이 사용자로 로그인하면 admin 페이지도 접근 가능하다)
    - Username: user
    - Password: 콘솔에 출력된 문자열 확인

#### 임시 패스워드
```java
2019-07-24 11:13:41.245  INFO 10848 --- [           main] .s.s.UserDetailsServiceAutoConfiguration : 

Using generated security password: 114284e0-656a-4fdf-b623-9b552a85b6c8
...
```

+ 해결된 문제
  - 인증을 할 수 있다.
  - 현재 사용자 정보를 알 수 있다.

+ 새로운 문제
  - 인증없이 접근 가능한 URL을 설정하고 싶다.
  - 이 애플리케이션을 사용할 수 있는 유저 계정이 그럼 하나 뿐인가?
  - 비밀번호가 로그에 남는다고?

## 스프링 시큐리티 설정하기
+ 스프링 웹 시큐리티 설정 추가

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .mvcMatchers("/", "/info").permitAll()
                .mvcMatchers("/admin").hasRole("ADMIN")
                .anyRequest().authenticated();

        http.formLogin(); // 시큐리티에서 제공하는 기본 폼 제공
        http.httpBasic();
    }
}
```
### 아래와 같이 해도 된다.
```java
  http.authorizeRequests()
                .mvcMatchers("/", "/info").permitAll()
                .mvcMatchers("/admin").hasRole("ADMIN")
                .anyRequest().authenticated()
                .and()
                .formLogin().and()
        http.httpBasic();
```


+ 해결한 문제
  - 요청 URL별 인증 설정

+ 남아있는 문제
  - 여전히 계정은 하나 뿐. 
  - ADMIN 계정도 없음.
  - 비밀번호도 여전히 로그에 남는다.

## 스프링 시큐리티 커스터마이징: 인메모리 유저 추가
+ 많은 방법 중 가장 간단한 방법

+ 지금까지 스프링 부트가 만들어 주던 유저 정보는?
	- UserDetailsServiceAutoConfiguration에서 가져온다. 
	- SecurityProperties에 User 정보가 있다.

+ application.properties에서도 추가 가능하다. (좋은방법이 아니다.)
	- spring.security.user.name=admin
	- spring.security.user.password=123
	- spring.security.user.roles=ADMIN

> 위 방법대로 properties를 사용해서 유저 정보를 변경할 수 있긴 하지만 좋은 방법이 아니다. 아래 메소드를 오버라이딩 하자

### SecurityConfig에 다음 설정 추가
```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.inMemoryAuthentication()
      .withUser("keesun").password("{noop}123").roles("USER").and() // {noop}: 기본 패스워드 인코더 구조, prefix에 {noop}이있으면 암호화 하여 값을 비교
      .withUser("admin").password("{noop}!@#").roles("ADMIN");
}

// 이부분은 설명안했지만 강의 자료에 있음
@Bean
@Override
public AuthenticationManager authenticationManagerBean() throws Exception {
    return super.authenticationManagerBean();
}
```
+ 인메모리 사용자 추가 // 이부분은 설명안했지만 강의 자료에 있음
+ 로컬 AuthenticationManager를 빈으로 노출 // 이부분은 설명안했지만 강의 자료에 있음

+ 해결한 문제
	- 계정 여러개 사용할 수 있음.
	- ADMIN 계정도 있음

+ 남아있는 문제
	- 사용자를 추가 할때마다 이런식으로 계속 코딩을 해줘야 할까?
	- 비밀번호가 코드에 보인다. 
	- 데이터베이스에 들어있는 유저 정보를 사용하고 싶다.

## 스프링 시큐리티 커스터마이징: JPA 연동
+ JPA와 H2 의존성 추가

+ implements UserDetailsService을 구현하고, loadUserByUsername을 오버라이딩해서 사용하면 된다.

+ 해결한 문제
	- 패스워드가 코드에 보이지 않는다.
	- DB에 들어있는 계정 정보를 사용할 수 있다.

+ 새로운 문제
	- “{noop}”을 없앨 수는 없을까?
	- 테스트는 매번 이렇게 해야 하는건가?
