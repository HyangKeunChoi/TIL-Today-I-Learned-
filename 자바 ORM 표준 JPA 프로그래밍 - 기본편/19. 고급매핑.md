
# 고급 매핑
#### 상속 관계 매핑

## 목차
+ 상속관계 매핑
+ @MappedSuperclass
+ 실전 예제 - 4. 상속관계 매핑

## 상속관계 매핑

+ 관계형 데이터베이스는 상속 관계X
+ 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
+ 상속관계 매핑: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑

## 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법(3가지)
1. 각각 테이블로 변환 -> 조인 전략 : 테이블을 조인 시켜 구현
2. 통합 테이블로 변환 -> 단일 테이블 전략 : 하나의 테이블로 합쳐서 구현
3. 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략 : 각 테이블마다 정보를 다 들고 있는 전략 

+ @Inheritance(strategy=InheritanceType.XXX)
  - JOINED: 조인 전략
  - SINGLE_TABLE: 단일 테이블 전략
  - TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
+ @DiscriminatorColumn(name=“DTYPE”)
  - DTYPE이라는 컬럼이 생성
  - 넣으면 좋다. 
  - 이름 변경도 가능
• @DiscriminatorValue(“XXX”)
  - 디폴트 값은 엔티티 이름(클래스 명)
  - DTYPE 컬럼 값이 세팅됨
  
## 1. 조인 전략
+ 장점
  - 테이블 정규화가 되어 있다.
  - 외래 키 참조 무결성 제약조건 활용가능
    - 예) ITEM_ID를 쓸 수 있다. (강의자료 참고)
  - 저장공간 효율화
+ 단점
  - 조회시 조인을 많이 사용, 성능 저하
  - 조회 쿼리가 복잡함
  - 데이터 저장시 INSERT SQL 2번 호출
  
## 2. 단일 테이블 전략
+ 구조가 단순할 떄 사용하면 좋다.

+ 장점
  - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
  - 조회 쿼리가 단순함
+ 단점
  - 자식 엔티티가 매핑한 컬럼은 모두 null 허용 (치명적인 단점)
  - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.
  
## 3. 구현 클래스마다 테이블 전략 - 사용하면 안됨
+ **이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천X**
+ 장점
  - 서브 타입을 명확하게 구분해서 처리할 때 효과적
  - not null 제약조건 사용 가능
+ 단점
  - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
  - 자식 테이블을 통합해서 쿼리하기 어려움  
  
  
## 결론
+ 조인 전략을 기본적으로 생각하고, 상황에 따라 단일 테이블 전략을 도입할 지 비교하여 활용 할 줄 알아야 한다.

